<tool id="preprocess_muon" name="Filter, normalize and preprocess multimodal data with muon" version="0.1.0">
    <requirements>
        <requirement type="package" version="1.7.0">scanpy</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        python '$script_file'
]]></command>
    <configfiles>
        <configfile name="script_file"><![CDATA[import scanpy as sc
import muon as mu
mdata = mu.read_h5mu('$mudata_input')

#if $method.method == 'filter_obs'
mu.pp.filter_obs(
    mdata,
    var='$method.filter_obs_var',
    func=$method.filter_obs_func
)

#else if $method.method == 'filter_var'
mu.pp.filter_var(
    mdata,
    var='$method.filter_var_var',
    func=$method.filter_var_func
)

#else if $method.method == 'intersect_obs'
mu.pp.intersect_obs(
    mdata
)

#else if $method.method == 'l2norm'
#set ($l2norm_mod) = ([x.strip() for x in str($method.l2norm_mod).split(',')])
#set ($l2norm_rep) = ([x.strip() for x in str($method.l2norm_rep).split(',')])
mu.pp.l2norm(
    mdata,
    mod=$l2norm_mod,
    rep=$l2norm_rep,
    n_pcs=$method.l2norm_n_pcs
)

#else if $method.method == 'neighbors'
mu.pp.neighbors(
    mdata,
    n_neighbors=$method.neighbors_n_neighbors,
    n_multineighbors=$method.neighbors_n_multineighbors,
    neighbor_keys='$method.neighbors_neighbor_keys',
    metric='$method.neighbors_metric',
    key_added='$method.neighbors_key_added',
    weight_key='$method.neighbors_weight_key',
    add_weights_to_modalities=$method.neighbors_add_weights_to_modalities,
    eps=$method.neighbors_eps
)
#end if

mdata.write("mudata_with_preprocessing.h5mu")
]]></configfile>
    </configfiles>
    <inputs>
        <param name="mudata_input" type="data" format="h5mu" label="MuData input file to run preprocessing" help="(.h5mu)"/>
        <conditional name="method">
            <param argument="method" type="select" label="Method used for plotting">
                    <option value="filter_obs">Filter: Filter observations (samples or cells) in-place using any column in .obs or in .X, using 'muon.pp.filter_obs'</option>
                    <option value="filter_var">Filter: Filter variables (features), using 'muon.pp.filter_var'</option>
                    <option value="intersect_obs">Subset: Subset observations (samples or cells) in-place taking observations present only in all modalities, using 'muon.pp.intersect_obs'</option>
                    <option value="l2norm">Normalize: Normalize observations to unit L2 norm, using 'muon.pp.l2norm'</option>
                    <option value="neighbors">Search: Multimodal nearest neighbor search, using 'muon.pp.neighbors'</option>
            </param>
            <when value="filter_obs">
                <param name="filter_obs_var" type="text" label="Column name in .obs or in .X to be used for filtering" help="(var)" value="total_counts"/>
                <param name="filter_obs_func" type="text" label="Function to apply to the variable used for filtering.
                If the variable is of type boolean and func is an identity function, the func argument can be omitted." help="(func), written as a lambda function e.g. lambda x: x < 5000" value="lambda x: x< 15000"/>
            </when>
            <when value="filter_var">
                <param name="filter_var_var" type="text" label="Column name in .var or row name in .X to be used for filtering" help="(var)" value="n_cells_by_count"/>
                <param name="filter_var_func" type="text" label="Function to apply to the variable used for filtering."
                       help="(func), written as a lambda function e.g. lambda x: x < 5000" value="lambda x: x< 15000"/>
            </when>
            <when value="intersect_obs"/>
            <when value="l2norm">
                <param name="l2norm_mod" type="text" label="Names of the modalities to normalize" help="(mod)"/>
                <param name="l2norm_rep" type="text" label="The representation to normalize. X or any key for .obsm is valid, for all modalities" help="(rep)"/>
                <param name="l2norm_n_pcs" type="text" label="The number of principal components to use. This affects the result only if a PCA representation is being normalized" help="(n_pcs)"/>
            </when>
            <when value="neighbors">
                <param name="neighbors_n_neighbors" type="text" label="Number of nearest neighbors to find" help="(n_neighbors)"/>
                <param name="neighbors_n_multineighbors" type="text" label="Number of nearest neighbors in each modality to consider as
                candidates for multimodal nearest neighbors. Only points in the union of per-modality nearest neighbors are candidates for
                multimodal nearest neighbors. This will use the same metric that was used for the nearest neighbor search in the respective modality"
                       value="200" help="(n_multineighbors)"/>
                <param name="neighbors_neighbor_keys" type="text" value="neighbors" label="Keys in .uns where per-modality neighborhood information is stored" help="(neighbor_keys)"/>
                <param name="neighbors_metric" type="text" value="euclidean" label="Distance measure to use. This will only be used in the final step to search for nearest neighbors in the set of candidates" help="(metric)"/>
                <param name="neighbors_key_added" type="text" label=" If specified, the neighbors data is added to .uns[key_added], distances are stored in .obsp[key_added + '_distances'] and connectivities in .obsp[key_added + '_connectivities']" help="(key_added)"/>
                <param name="neighbors_weight_key" type="text" value="mod_weight" label="Weight key to add to each modalityâ€™s .obs or to mdata.obs" help="(weight_key)"/>
                <param name="neighbors_add_weights_to_modalities" type="boolean" truevalue="True" falsevalue="False" checked="false" label="If to add weights to individual modalities. By default, it is False and the weights will be added to mdata.obs" help="(add_weights_to_modalities)"/>
                <param name="neighbors_eps" type="float" label="Small number to avoid numerical errors." value="0.0001" help="(eps)"/>
            </when>
        </conditional>
    </inputs>
    <outputs>
        <data name="mudata_with_preprocessing" format="h5mu" label="MuData with Preprocessing" from_work_dir="mudata_with_preprocessing.h5mu"/>
    </outputs>
    <tests>
        <test>
            <param name="mudata_input" value="mudata_input.h5mu"/>
            <output name="mudata_with_preprocessing" file="mudata_with_preprocessing.h5mu"/>
        </test>
    </tests>
    <help><![CDATA[
    **What it does**
        Import MuData from AnnData is a tool that allows creating a muon.MuData object out of two AnnData objects
        for multimodal omics factorial analysis.
        Furthermore, it runs pp.intersect_obs to keep only entries present in both modalities (AnnData objects) in the
        final MuData file.

    ]]></help>
    <citations>/
        <citation type="bibtex">
}</citation>
    </citations>
</tool>